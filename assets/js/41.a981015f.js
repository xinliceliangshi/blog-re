(window.webpackJsonp=window.webpackJsonp||[]).push([[41],{448:function(n,i,e){"use strict";e.r(i);var t=e(2),s=Object(t.a)({},(function(){var n=this,i=n._self._c;return i("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[i("p",[n._v("快速排序算法模板 —— 模板题 AcWing 785. 快速排序")]),n._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",[i("code",[n._v("void quick_sort(int q[], int l, int r)\n{\nif (l >= r) return;\nint i = l - 1, j = r + 1, x = q[l + r >> 1];\nwhile (i < j)\n{\n    do i ++ ; while (q[i] < x);\n    do j -- ; while (q[j] > x);\n    if (i < j) swap(q[i], q[j]);\n}\nquick_sort(q, l, j), quick_sort(q, j + 1, r);\n}\n")])])]),i("div",{staticClass:"language- extra-class"},[i("pre",{pre:!0,attrs:{class:"language-text"}},[i("code",[n._v("\n")])])]),i("p",[n._v("归并排序算法模板 —— 模板题 AcWing 787. 归并排序")]),n._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",[i("code",[n._v("void merge_sort(int q[], int l, int r)\n{\n    if (l >= r) return;\nint mid = l + r >> 1;\nmerge_sort(q, l, mid);\nmerge_sort(q, mid + 1, r);\n\nint k = 0, i = l, j = mid + 1;\nwhile (i <= mid && j <= r)\n    if (q[i] <= q[j]) tmp[k ++ ] = q[i ++ ];\n    else tmp[k ++ ] = q[j ++ ];\n\nwhile (i <= mid) tmp[k ++ ] = q[i ++ ];\nwhile (j <= r) tmp[k ++ ] = q[j ++ ];\n\nfor (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];\n")])])]),i("p",[n._v("}\n整数二分算法模板 —— 模板题 AcWing 789. 数的范围")]),n._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",{pre:!0,attrs:{class:"language-text"}},[i("code",[n._v("bool check(int x) {/* ... */} // 检查x是否满足某种性质\n\n// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：\nint bsearch_1(int l, int r)\n{\n    while (l < r)\n    {\n        int mid = l + r >> 1;\n        if (check(mid)) r = mid;    // check()判断mid是否满足性质\n        else l = mid + 1;\n    }\n    return l;\n}\n// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：\nint bsearch_2(int l, int r)\n{\n    while (l < r)\n    {\n        int mid = l + r + 1 >> 1;\n        if (check(mid)) l = mid;\n        else r = mid - 1;\n    }\n    return l;\n}\n")])])]),i("p",[n._v("浮点数二分算法模板 —— 模板题 AcWing 790. 数的三次方根")]),n._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",{pre:!0,attrs:{class:"language-text"}},[i("code",[n._v("bool check(double x) {/* ... */} // 检查x是否满足某种性质\n\ndouble bsearch_3(double l, double r)\n{\n    const double eps = 1e-6;   // eps 表示精度，取决于题目对精度的要求\n    while (r - l > eps)\n    {\n        double mid = (l + r) / 2;\n        if (check(mid)) r = mid;\n        else l = mid;\n    }\n    return l;\n}\n")])])]),i("p",[n._v("高精度加法 —— 模板题 AcWing 791. 高精度加法\n// C = A + B, A >= 0, B >= 0")]),n._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",[i("code",[n._v("vector<int> add(vector<int> &A, vector<int> &B)\n{\n    if (A.size() < B.size()) return add(B, A);\nvector<int> C;\nint t = 0;\nfor (int i = 0; i < A.size(); i ++ )\n{\n    t += A[i];\n    if (i < B.size()) t += B[i];\n    C.push_back(t % 10);\n    t /= 10;\n}\n\nif (t) C.push_back(t);\nreturn C;\n}\n")])])]),i("p",[n._v("高精度减法 —— 模板题 AcWing 792. 高精度减法\n// C = A - B, 满足A >= B, A >= 0, B >= 0")]),n._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",[i("code",[n._v("vector<int> sub(vector<int> &A, vector<int> &B)\n{\n    vector<int> C;\n    for (int i = 0, t = 0; i < A.size(); i ++ )\n    {\n        t = A[i] - t;\n        if (i < B.size()) t -= B[i];\n        C.push_back((t + 10) % 10);\n        if (t < 0) t = 1;\n        else t = 0;\n    }\nwhile (C.size() > 1 && C.back() == 0) C.pop_back();\nreturn C;\n}\n")])])]),i("p",[n._v("高精度乘低精度 —— 模板题 AcWing 793. 高精度乘法\n// C = A * b, A >= 0, b >= 0")]),n._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",{pre:!0,attrs:{class:"language-text"}},[i("code",[n._v("vector<int> mul(vector<int> &A, int b)\n{\n    vector<int> C;\n\n    int t = 0;\n    for (int i = 0; i < A.size() || t; i ++ )\n    {\n        if (i < A.size()) t += A[i] * b;\n        C.push_back(t % 10);\n        t /= 10;\n    }\n    \n    while (C.size() > 1 && C.back() == 0) C.pop_back();\n    \n    return C;\n\n}\n")])])]),i("p",[n._v("高精度除以低精度 —— 模板题 AcWing 794. 高精度除法\n// A / b = C ... r, A >= 0, b > 0")]),n._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",{pre:!0,attrs:{class:"language-text"}},[i("code",[n._v("vector<int> div(vector<int> &A, int b, int &r)\n{\n    vector<int> C;\n    r = 0;\n    for (int i = A.size() - 1; i >= 0; i -- )\n    {\n        r = r * 10 + A[i];\n        C.push_back(r / b);\n        r %= b;\n    }\n    reverse(C.begin(), C.end());\n    while (C.size() > 1 && C.back() == 0) C.pop_back();\n    return C;\n}\n")])])]),i("p",[n._v("一维前缀和 —— 模板题 AcWing 795. 前缀和\nS[i] = a[1] + a[2] + ... a[i]\na[l] + ... + a[r] = S[r] - S[l - 1]\n二维前缀和 —— 模板题 AcWing 796. 子矩阵的和\nS[i, j] = 第i行j列格子左上部分所有元素的和\n以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：\nS[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]\n一维差分 —— 模板题 AcWing 797. 差分\n给区间[l, r]中的每个数加上c：B[l] += c, B[r + 1] -= c\n二维差分 —— 模板题 AcWing 798. 差分矩阵\n给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：\nS[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c\n位运算 —— 模板题 AcWing 801. 二进制中1的个数\n求n的第k位数字: n >> k & 1\n返回n的最后一位1：lowbit(n) = n & -n\n双指针算法 —— 模板题 AcWIng 799. 最长连续不重复子序列, AcWing 800. 数组元素的目标和")]),n._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",{pre:!0,attrs:{class:"language-text"}},[i("code",[n._v("for (int i = 0, j = 0; i < n; i ++ )\n{\n    while (j < i && check(i, j)) j ++ ;\n\n    // 具体问题的逻辑\n\n}\n\n")])])]),i("p",[n._v("常见问题分类：\n(1) 对于一个序列，用两个指针维护一段区间\n(2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作\n离散化 —— 模板题 AcWing 802. 区间和")]),n._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",{pre:!0,attrs:{class:"language-text"}},[i("code",[n._v("vector<int> alls; // 存储所有待离散化的值\nsort(alls.begin(), alls.end()); // 将所有值排序\nalls.erase(unique(alls.begin(), alls.end()), alls.end());   // 去掉重复元素\n")])])]),i("p",[n._v("// 二分求出x对应的离散化的值")]),n._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",{pre:!0,attrs:{class:"language-text"}},[i("code",[n._v("int find(int x) // 找到第一个大于等于x的位置\n{\n    int l = 0, r = alls.size() - 1;\n    while (l < r)\n    {\n        int mid = l + r >> 1;\n        if (alls[mid] >= x) r = mid;\n        else l = mid + 1;\n    }\n    return r + 1; // 映射到1, 2, ...n\n}\n\n")])])]),i("p",[n._v("区间合并 —— 模板题 AcWing 803. 区间合并\n// 将所有存在交集的区间合并")]),n._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",[i("code",[n._v("void merge(vector<PII> &segs)\n{\n    vector<PII> res;\nsort(segs.begin(), segs.end());\n\nint st = -2e9, ed = -2e9;\nfor (auto seg : segs)\n    if (ed < seg.first)\n    {\n        if (st != -2e9) res.push_back({st, ed});\n        st = seg.first, ed = seg.second;\n    }\n    else ed = max(ed, seg.second);\n\nif (st != -2e9) res.push_back({st, ed});\n\nsegs = res;}\n")])])])])}),[],!1,null,null,null);i.default=s.exports}}]);